#pragma once
#include "./any.ii"
#include "../square1.ii"





XTAL_ENV_(push)
namespace xtal::math::pade
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

template <int N_fun=1, int N_hyp=0, int N_div=0, int N_car=0> XTAL_NYM circle1 {static_assert(N_fun);};
template <int N_fun=1, int N_hyp=0, int N_div=0, int N_car=0> XTAL_USE circle1_t = process::confined_t<circle1<N_fun, N_hyp, N_div, N_car>>;

//template <int N_fun, int N_hyp>
//struct circle1<N_fun, N_hyp, 0, +1>
//:	bond::compose<patio<-2>, circle1<N_fun, N_hyp, 0, 0>>
//{};
/*/
template <int N_fun, int N_hyp, int N_div>
struct circle1<N_fun, N_hyp, N_div, -0>
:	bond::compose<discard<1>, circle1<N_fun, N_hyp, N_div, -1>>
{};
/*/
template <int N_fun, int N_hyp>
struct circle1<N_fun, N_hyp, 1, -0>
:	bond::compose<discard<1>, circle1<N_fun, N_hyp, 1, -1>>
{};
/***/

/*/
template <int N_fun, int N_hyp, int N_div>
struct circle1<N_fun, N_hyp, N_div, -1>
:	bond::compose<discard<2>, circle1<N_fun, N_hyp, N_div, -2>>
{};
/*/
template <int N_fun, int N_hyp>
struct circle1<N_fun, N_hyp, 1, -1>
:	bond::compose<discard<2>, circle1<N_fun, N_hyp, 1, -2>>
{};
/***/


////////////////////////////////////////////////////////////////////////////////

template <int N_fun, int N_hyp, int N_div> requires in_p<N_fun, 1>
struct circle1<N_fun, N_hyp, N_div, 0>
{
	using subkind = circle1<N_fun, N_hyp, 0, 0>;

	template <class S>
	class subtype: public bond::compose_s<S, subkind>
	{
		using S_ = bond::compose_s<S, subkind>;

	public:
		using S_::S_;

		template <int N_lim>
		XTAL_FN2 function(auto const &w)
		XTAL_0EX
		{
			using re = bond::realize<decltype(w)>;
			return S_::function(w*re::haplo_f(N_div));
		}
		template <int N_lim>
		XTAL_FN2 function(group::cycle_q auto w)
		XTAL_0EX
		{
			return S_::function(w >> N_div);
		}

	};
};
template <int N_fun, int N_hyp> requires in_p<N_fun, 1>
struct circle1<N_fun, N_hyp, 0, 0>
{
	using subkind = process::lifted<square1_t<1, N_hyp>, circle1_t<N_fun, N_hyp, 1, 0>>;

	template <class S>
	class subtype: public bond::compose_s<S, subkind>
	{
		using S_ = bond::compose_s<S, subkind>;

	public:
		using S_::S_;

		template <int N_lim>
		XTAL_FN2 function(simplex_field_p auto w)
		XTAL_0EX
		{
			using W = decltype(w); using re = bond::realize<W>;
			using Z = _std::complex<W>;
			using alpha_t = typename re::alpha_t;
			using sigma_t = typename re::sigma_t;
			using delta_t = typename re::delta_t;

			if constexpr (N_lim < 0) {
				w *= re::patio_2;
				XTAL_IF0
				XTAL_0IF_(N_hyp&1^1) {return Z {_std::cos (w), _std::sin (w)};}
				XTAL_0IF_(N_hyp&1^0) {return Z {_std::cosh(w), _std::sinh(w)};}
			}
			else {
				w -= _std::round(w);
				auto u = w;
				u *=   re::diplo_1;
				u -= _std::round(u);
				u *=   re::haplo_1;
				return S_::template function<N_lim>(u)*re::assign_f(u != w);
			}
		}
		template <int N_lim>
		XTAL_FN2 function(group::cycle_q auto w)
		XTAL_0EX
		{
			using re = bond::realize<decltype(w.size())>;
			using alpha_t = typename re::alpha_t;
			using sigma_t = typename re::sigma_t;
			using delta_t = typename re::delta_t;

			if constexpr (N_lim < 0) {
				return function<N_lim>(w(0));
			}
			else {
				auto const v = w[0] & re::sign.mask;
				w[0] &= re::positive.mask >> 1;
				w[0] |=                 v >> 1;
				return S_::template function<N_lim>(w(0))*re::assign_f(v);
			}
		}

	};
};


////////////////////////////////////////////////////////////////////////////////

template <int N_fun, int N_hyp> requires in_p<N_fun, 1>
struct circle1<N_fun, N_hyp, 1, -2>
{
	template <class S>
	class subtype: public bond::compose_s<S>
	{
		using S_ = bond::compose_s<S>;

	public:
		using S_::S_;

		template <int N_lim>
		XTAL_FN2 function(simplex_field_p auto const &w)
		XTAL_0EX
		{
			int constexpr I_lim = N_lim&0x7;
			int constexpr I_sgn = sign_n<N_hyp&1^0, -1>;

			using W = XTAL_TYP_(w); using re = bond::realize<W>;
			using Z = _std::complex<W>;

			using alpha_t = typename re::alpha_t;
			using sigma_t = typename re::sigma_t;
			using delta_t = typename re::delta_t;

			XTAL_IF0
			XTAL_0IF_(I_lim == 0x0) {// 0:1 D[...0]@0 && D[...0]@¼
				alpha_t constexpr x0 = 1.000000000000000000000000000000000000;// 1
				alpha_t constexpr y0 = 3.141592653589793238462643383279502884;
				auto x = horner::polynomial_f<I_sgn>(w, x0);
				auto y = horner::polynomial_f<I_sgn>(w, y0);
				return Z {x, y};
			}
			XTAL_0IF_(I_lim == 0x1) {// 2:1 D[...1]@0 && D[...0]@¼
				alpha_t constexpr x0 = 1.000000000000000000000000000000000000;// 1
				alpha_t constexpr x1 = 3.433629385640827046149426466881988463;
				alpha_t constexpr y0 = 3.141592653589793238462643383279502884;
				auto x = horner::polynomial_f<I_sgn>(w, x0, x1);
				auto y = horner::polynomial_f<I_sgn>(w, y0);
				return Z {x, y};
			}
			XTAL_0IF_(I_lim == 0x2) {// 2:3 D[...1]@0 && D[...1]@¼
				alpha_t constexpr x0 = 1.000000000000000000000000000000000000;// 1
				alpha_t constexpr x1 = 3.968985697854261420737444775816737932;
				alpha_t constexpr y0 = 3.141592653589793238462643383279502884;// pi
				alpha_t constexpr y1 = 2.141425248853737498352073235738997875;
				auto x = horner::polynomial_f<I_sgn>(w, x0, x1);
				auto y = horner::polynomial_f<I_sgn>(w, y0, y1);
				return Z {x, y};
			}
			XTAL_0IF_(I_lim == 0x3) {// 4:3 D[...2]@0 && D[...2]@¼
				alpha_t constexpr x0 = 1.000000000000000000000000000000000000;// 1
				alpha_t constexpr x1 = 4.237909660449236428693854535224051104;
				alpha_t constexpr x2 = 0.955351046282004540229507364731116905;
				alpha_t constexpr y0 = 3.141592653589793238462643383279502884;// pi
				alpha_t constexpr y1 = 2.978283337663136395120335432185471337;
				auto x = horner::polynomial_f<I_sgn>(w, x0, x1, x2);
				auto y = horner::polynomial_f<I_sgn>(w, y0, y1);
				return Z {x, y};
			}
			XTAL_0IF_(I_lim == 0x4) {// 4:5 D[...2]@0 && D[...3]@¼
				alpha_t constexpr x0 = 1.000000000000000000000000000000000000;// 1
				alpha_t constexpr x1 = 4.390338960642080575102860479411085957;
				alpha_t constexpr x2 = 1.561426046129173147274250250239938996;
				alpha_t constexpr y0 = 3.141592653589793238462643383279502884;// pi
				alpha_t constexpr y1 = 3.457231542101901520792301595993191760;
				alpha_t constexpr y2 = 0.331996058066891068754049734988584509;
				auto x = horner::polynomial_f<I_sgn>(w, x0, x1, x2);
				auto y = horner::polynomial_f<I_sgn>(w, y0, y1, y2);
				return Z {x, y};
			}
			XTAL_0IF_(I_lim == 0x5) {// 6:5 D[...3]@0 && D[...3]@¼
				alpha_t constexpr x0 = 1.000000000000000000000000000000000000;// 1
				alpha_t constexpr x1 = 4.487894813803155707106642350629568074;
				alpha_t constexpr x2 = 1.975104599215236121543726210642557678;
				alpha_t constexpr x3 = 0.094096528134246695768752645930262507;
				alpha_t constexpr y0 = 3.141592653589793238462643383279502884;// pi
				alpha_t constexpr y1 = 3.763711817027786915281807613442402050;
				alpha_t constexpr y2 = 0.623295934882939155479821936321002832;
				auto x = horner::polynomial_f<I_sgn>(w, x0, x1, x2, x3);
				auto y = horner::polynomial_f<I_sgn>(w, y0, y1, y2);
				return Z {x, y};
			}
			XTAL_0IF_(I_lim == 0x6) {// 6:7 D[...3]@0 && D[...4]@¼
				alpha_t constexpr x0 = 1.000000000000000000000000000000000000;// 1
				alpha_t constexpr x1 = 4.556288946308768410678019439942678932;
				alpha_t constexpr x2 = 2.275378023833944536636939235400154936;
				alpha_t constexpr x3 = 0.200888908030920297664420149309522799;
				alpha_t constexpr y0 = 3.141592653589793238462643383279502884;// pi
				alpha_t constexpr y1 = 3.978578321256066662987441200793155884;
				alpha_t constexpr y2 = 0.859750287076040352418274981236440341;
				alpha_t constexpr y3 = 0.022706582386768037080226242510354953;
				auto x = horner::polynomial_f<I_sgn>(w, x0, x1, x2, x3);
				auto y = horner::polynomial_f<I_sgn>(w, y0, y1, y2, y3);
				return Z {x, y};
			}
			XTAL_0IF_(I_lim == 0x7) {// 8:7 D[...4]@0 && D[...5]@¼
				alpha_t constexpr x0 = 1.000000000000000000000000000000000000;// 1
				alpha_t constexpr x1 = 4.606547402370024772724248519073301565;
				alpha_t constexpr x2 = 2.500953736670776238483254500604284293;
				alpha_t constexpr x3 = 0.300243870518009486091801923099845388;
				alpha_t constexpr x4 = 0.004749448374844164315053279863807317;
				alpha_t constexpr y0 = 3.141592653589793238462643383279502884;// pi
				alpha_t constexpr y1 = 4.136469917598875065501883380414805209;
				alpha_t constexpr y2 = 1.048974757862995076084471175276645114;
				alpha_t constexpr y3 = 0.054095324243024101847331195900039153;
				auto x = horner::polynomial_f<I_sgn>(w, x0, x1, x2, x3, x4);
				auto y = horner::polynomial_f<I_sgn>(w, y0, y1, y2, y3);
				return Z {x, y};
			}
		}

	};
};


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
