#pragma once
#include "./any.ii"

#include "../dilate.ii"
#include "../square.ii"
#include "../taylor/sine.ii"


XTAL_ENV_(push)
namespace xtal::math::jonquiere
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

template <int N_fix=1, int N_hyp=0, int N_car=0> struct logarithm {static_assert(N_fix);};
template <int N_fix=1, int N_hyp=0, int N_car=0> using  logarithm_t = process::confined_t<logarithm<N_fix, N_hyp, N_car>>;
template <int N_fix=1, int N_hyp=0, int N_car=0>
XTAL_FN2 logarithm_f(auto &&o)
XTAL_0EX
{
	return logarithm_t<N_fix, N_hyp, N_car>::function(XTAL_REF_(o));
}

////////////////////////////////////////////////////////////////////////////////
///\
Defines `function` as the polylogarithm `-Log[1 - #]`, \
approximated by `#/Sqrt[1 - #]`. \

template <int N_hyp>
struct logarithm<(+1), N_hyp, -0>
{
	using subkind = process::inferred<void
	,	process::confined_t<dilate<+1>, taylor::sine<(-1), 1>>
	,	process::confined_t<discard<1>, logarithm<(+1), N_hyp, -1>>
	>;

	template <class S>
	class subtype: public bond::compose_s<S, subkind>
	{
		using S_ = bond::compose_s<S, subkind>;

	public:
		using S_::S_;

		template <int N_lim=-1>
		XTAL_FN2 function(auto &&o)
		XTAL_0EX
		{
			using re = bond::realize<decltype(o)>;
			auto constexpr v1 = re::alpha_1;
			auto constexpr vS = re::alpha_1*sign_n<N_hyp&1, -1>;

			if constexpr (N_lim < 0) {
				return _std::log(v1 + XTAL_REF_(o)*vS)*vS;
			}
			else {
				return S_::template function<N_lim>(typename re::alpha_t(XTAL_REF_(o)));
			}
		}

	};
};
///\
Defines `function` as the antipolylogarithm `1 - Exp[-#]`, \
approximated by `(Sqrt[1 + (#/2)^2] - (#/2))*(#)`. \

template <int N_hyp>
struct logarithm<(-1), N_hyp, -0>
{
	using subkind = process::inferred<void
	,	process::confined_t<discard<1>, logarithm<(-1), N_hyp, -1>>
	,	process::confined_t<dilate<+1>, taylor::sine<(+1), 1>>
	>;

	template <class S>
	class subtype: public bond::compose_s<S, subkind>
	{
		using S_ = bond::compose_s<S, subkind>;

	public:
		using S_::S_;

		template <int N_lim=0>
		XTAL_FN2 function(auto &&o)
		XTAL_0EX
		{
			using re = bond::realize<decltype(o)>;
			auto constexpr v1 = re::alpha_1;
			auto constexpr vS = re::alpha_1*sign_n<N_hyp&1, -1>;

			if constexpr (N_lim < 0) {
				return (_std::exp(XTAL_REF_(o)*vS) - v1)*vS;
			}
			else {
				return S_::template function<N_lim>(XTAL_REF_(o));
			}
		}

	};
};


////////////////////////////////////////////////////////////////////////////////
///\
Defines `function` as the cardinal polylogarithm `-Log[1 - #]/#`, \
approximated by `1/Sqrt[1 - #]`. \

template <int N_hyp>
struct logarithm<(+1), N_hyp, -1>
{
	template <class S>
	class subtype: public bond::compose_s<S>
	{
		using S_ = bond::compose_s<S>;

	public:
		using S_::S_;

		template <int N_lim=0>
		XTAL_FN2 function(auto &&u)
		XTAL_0EX
		{
			using re = bond::realize<decltype(u)>;
			auto constexpr v1 = re::alpha_1;
			auto constexpr vS = re::alpha_1*sign_n<N_hyp&1, -1>;

			if constexpr (N_lim < 0) {
				return logarithm_t<(+1), N_hyp, -0>::template function<-1>(u)/XTAL_REF_(u);
			}
			else {
				return square_f<-1,-1>(v1 + vS*XTAL_REF_(u));
			}
		}

	};
};
///\
Defines `function` as the cardinal antipolylogarithm `1 - Exp[-#]/#`, \
approximated by `Sqrt[1 + (#/2)^2] + (#/2)`. \

template <int N_hyp>
struct logarithm<(-1), N_hyp, -1>
{
	template <class S>
	class subtype: public bond::compose_s<S>
	{
		using S_ = bond::compose_s<S>;

	public:
		using S_::S_;

		template <int N_lim=0>
		XTAL_FN2 function(auto &&o)
		XTAL_0EX
		{
			using re = bond::realize<decltype(o)>;
			auto constexpr v1 = re::alpha_1;
			auto constexpr vS = re::alpha_1*sign_n<N_hyp&1, -1>;

			if constexpr (N_lim < 0) {
				return logarithm_t<(-1), N_hyp, -0>::template function<-1>(o)/XTAL_REF_(o);
			}
			else {
				auto u = XTAL_REF_(o)*re::haplo_f(1);
				return square_f<-1, 1>(square_f<+1, 1>(u) + v1) + u*vS;
			}
		}

	};
};


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
