#pragma once
#include "./any.ii"






XTAL_ENV_(push)
namespace xtal::math
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

template <int N_fix=1, int N_hyp=0> XTAL_NYM square1;
template <int N_fix=1, int N_hyp=0> XTAL_USE square1_t = process::confined_t<square1<N_fix, N_hyp>>;


////////////////////////////////////////////////////////////////////////////////

template <int N_hyp>
struct square1<0, N_hyp>
{
	template <class S>
	class subtype: public bond::compose_s<S>
	{
		using S_ = bond::compose_s<S>;

	public:
		using S_::S_;

		template <auto ...Is>
		XTAL_FN2 function(auto &&o)
		XTAL_0EX
		{
			return S_::template function<Is...>(XTAL_REF_(o));
		}

	};
};
template <int N_fix, int N_hyp> requires (0 < N_fix)
struct square1<N_fix, N_hyp>
{
	XTAL_LET_(int) I_fix = +N_fix;
	XTAL_LET_(int) I_sgn = sign_n<N_hyp&1^1, -1>;

	template <class S>
	class subtype: public bond::compose_s<S>
	{
		using S_ = bond::compose_s<S>;

	public:
		using S_::S_;

		template <auto ...Is>
		XTAL_FN2 function(complex_field_q auto const &o)
		XTAL_0EX
		{
		//	using W = XTAL_TYP_(o); using re = bond::realized<W>;

			auto y = o.imag();
			auto x = o.real();
			bond::seek_forward_f<I_fix>([&] (auto) XTAL_0FN {
				auto const yy = y*y;//square1_f<1>(y);
				auto const xx = x*x;//square1_f<1>(x);
				auto const y_ = 2*x*y;
				auto const x_ = xx - yy*I_sgn;
				auto const w_ = xx + yy*I_sgn;
				auto const m_ = 1/w_;
				y = y_*m_;
				x = x_*m_;
			});
			return XTAL_TYP_(o) {x, y};
		}

	};
};


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
